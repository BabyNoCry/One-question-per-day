题目描述
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
输入描述:
输入一个数n，意义见题面。（2 <= n <= 60）
输出描述:
输出答案。
示例1
输入
复制
8



使用动态规划解决
动态规划，先自上而下分析，在长度为n的绳子所求为f(n)，剪下一刀后剩下的两段长度是i和n-i，在这个上面还可能继续减(子问题)，所以：
f(n)=max(f(i)×f(n-i)) f(n)=max(f(i)\times f(n-i))
f(n)=max(f(i)×f(n-
i))

然后自下而上的解决问题，可以从f(1)开始向上计算并打表保存，最终获得f(n)的值。

class Solution {
public:
    int cutRope(int number) {
        
        //因为 剪下的段数  m  > 1,,所以这里返回0表示输入非法 
       if(number < 2)
           return 0;
        //长度为2时,因为要求剪下段数m>1,所以最大是1x1=1 
        if(number == 2)
            return 1;
        //长度为3时,因为要求剪下段数m>1,所以最大是1x2=2 
        if(number == 3)
            return 2;
        
        vector<int> ret(number + 1);
        ret[0] = 0;
        ret[1] = 1;
        ret[2] = 2;
        ret[3] = 3;    //到3为止都是不剪最好 
        int max = 0;     //用于记录最大乘积
        for(int i = 4 ; i <= number; i++)
        {
             max = 0;
            for(int j = 1; j<= i/2 ; j++)
            {	
                //因为要计算f(j)乘以f(i-j)的最大值,j超过i的一半时是重复计算
		        //所以只需要考虑j不超过i的一半的情况 
               int tmp = ret[j] * ret[i-j];
                
                if(max < tmp)
                    max = tmp;
            }
            ret[i] = max;
        }
        
        return ret[number];
        
        
    }
};


使用贪心算法使用贪心法解决
当n>=5 n>=5n>=5时，3(n?3)>=2(n?2) 3(n-3)>=2(n-2)3(n?3)>=2(n?2)且只在n取5时取等号，且它们都大于n nn，
所以应把绳子剪成尽量多的3，让剩下的都是2这样的组合。

书上言尽于此，我想了下如果剪成其它大小的会不会更好。
如果剪成4，那么4=2×2=2+2 4=2\times 2=2+24=2×2=2+2就还是和剪成两个2一样，如果剪成5，那么5还能继续剪剪成3和2，往后也是一样。
试想更大的数，比如15，得到一段15以后不剪是不可能的，因为前面说了这时候3(n?3)>2(n?2)>n 3(n-3)>2(n-2)>n3(n?3)>2(n?2)>n，
那么剪成更小的段，只要不小于5就一定满足这个就要继续减，如果比5小，从1~4的情况都想过了，4是不用管的或者剪成两个2，3就保留，2也保留，1不要出现。

//输入绳子的长度,输出最大乘积 
int maxProductAfterCutting_solution2(int length) {
	if(length < 2)//因为要求长度n>1,所以这里返回0表示输入非法 
		return 0;
	if(length == 2)//长度为2时,因为要求剪下段数m>1,所以最大是1x1=1 
		return 1;
	if(length == 3)//长度为3时,因为要求剪下段数m>1,所以最大是1x2=2 
		return 2;

	//尽可能多地减去长度为3的绳子段,这里是计算一下能减出多少个3 
	int timesOf3 = length / 3;

	//当绳子最后剩下的长度为4的时候,不能再剪去长度为3的绳子段。
	//此时更好的方法是把绳子剪成长度为2的两段,因为2*2>3*1。
	if(length - timesOf3 * 3 == 1)//如果最后只剩一个1 
		timesOf3 -= 1;//就要留下一个3 

	//保证剩下的一定是4或者2或者0,计算一下能剪出几个2来(只有2/1/0三种情况) 
	int timesOf2 = (length - timesOf3 * 3) / 2;
	
	//3的多少个3次幂,再乘以2的多少个2次幂,就是贪心选择的最优解 
	return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));
}

