题目描述
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，
那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：
 {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

方法：除了暴力查找外，这里我们换用另外一种方法：使用双端队列。我们不把所有的值都加入滑动窗口，而是只把有可能成为最大值的数加入滑动窗口。这就需要一个两边都可以操作的双向队列。

??我们以数组{2,3,4,2,6,2,5,1}为例，滑动窗口大小为3，先把第一个数字2加入队列，第二个数字是3，比2大，所以2不可能是最大值，所以把2删除，3存入队列。第三个数是4，比3大，同样删3存4，此时滑动窗口以遍历三个数字，最大值4在队列的头部。

??第4个数字是2，比队列中的数字4小，当4滑出去以后，2还是有可能成为最大值的，因此将2加入队列尾部，此时最大值4仍在队列的头部。

??第五个数字是6，队列的数字4和2都比它小，所以删掉4和2，将6存入队列尾部，此时最大值6在队列头部。

??第六个数字是2，此时队列中的数6比2大，所以2以后还有可能是最大值，所以加入队列尾部，此时最大值6在仍然队列头部。

??・・・・・・

??依次进行，这样每次的最大值都在队列头部。

??还有一点需要注意的是：如果后面的数字都比前面的小，那么加入到队列中的数可能超过窗口大小，这时需要判断滑动窗口是否包含队头的这个元素，为了进行这个检查，我们可以在队列中存储数字在数组中的下标，
而不是数值，当一个数字的下标和当前出来的数字下标之差大于等于滑动窗口的大小时，这个元素就应该从队列中删除。
//方法一： 暴力查找，效率很低 O(N^2)
//方法二：使用双端队列。
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> ret;
        if(num.size() < size || size <1)
            return ret;
        deque<int> index;    //存放下标
        for(int i = 0;i < num.size();i++)
        {
            if(index.empty())
            {
                index.push_back(i);
            }
            else
            {
                while(!index.empty() && i - index.front() >= size)
                {
                    index.pop_front();
                }
                while(!index.empty() && num[index.back()] <= num[i] )
                {
                    index.pop_back();
                }
                index.push_back(i);
            }
            if( i >= size-1)
            {
                ret.push_back(num[index.front()]);
            }
        }
        return ret;
    }
};