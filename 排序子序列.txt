排序子序列
牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.
如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2

输入描述:
输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)

第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。


输出描述:
输出一个整数表示牛牛可以将A最少划分为多少段排序子序列
示例1
输入
6
1 2 3 2 2 1
输出
2

【题目解析】：
本题要求解的是排序子序列，排序子序列为非递增或者非递减，很多同学在这个非递增、非递减问题上很纠
结，注意：非递减就是a[i]<=a[i+1]，递减就是a[i]>a[i+1]，非递增就是a[i]>=a[i+1]，递增就是a[i]<a[i+1]。
其实这个不理解网上搜一下就理解了。
【解题思路】：
通过上面理解了排序子序列，如果我们把这里值画到一个坐标图里面，本质就是去找这里图里面的波峰和波
谷的个数，再加一。
比如：
// 情况一：在这里我们可以看到 1 2 3是一个递增序列，也可以认为是一个非递减序列
// 在这里我们可以看到 2 2 1是一个非递增序列
     3
   2   2  2
1             1
// 情况二：需要注意这里如果去算波峰和波谷有两个，但是要注意，一个排序子序列至少需要有两个数构成，
// 所以这里的的排序子序列不是3个，是两个：1 3 和 2 3
   3     3
      2
1

#include<iostream>
#include<vector>
using namespace std;
int main()
{
    vector<int> v;
    int n;
    cin>>n;
    
    v.resize(n);
    for(int i = 0;i<n;i++)
        cin>>v[i];
    int ret = 1;
    
    for(int i = 1; i< n-1; i++)
    {
        if((v[i-1]>v[i]&&v[i]<v[i+1])||(v[i-1]<v[i]&&v[i]>v[i+1]))
        {
            ret++;
            if(i!= n-3)
            i++;
            
        }
    }
    cout<<ret<<endl;
    return 0;
}