链接：https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a
来源：牛客网

从题目中来看，小猴子每次将桃子均分为 5 堆时都会多出来 1 个，所以为了方便计算，我们在最开始时就借给猴子们 4 个桃子，这样的话，每次都可以刚好均分为 5 堆。

　　假设在开始时就有 X 个桃子，借给猴子们 4 个后，此时就一共有 X+4 个桃子。
　　当第一只小猴子来时，它将 X+4 个桃子均分为 5 堆后，拿走 (X+4)*(1/5) 个，剩余 (X+4)*(4/5) 个桃子。在这里，有人可能会有疑问：给老猴子的那个桃子去哪里呢？其实，小猴子拿的那一部分就包括了这一个桃子，并且小猴子也没有多得桃子，它实际上得到的桃子数为 (X+4)*(1/5) - 1 = (X-1)*(1/5) ，这和在不借给它们 4 个桃子的情况下得到的数量是一样的，不过此时剩余的桃子数相较于之前多了 (X+4)*(4/5) - (X-1)*(4/5) = 4 个，但这样就恰巧保证了下一只小猴子分桃时，也能刚好均分为 5 堆。由此可见，所有的小猴子都不会多得桃子，老猴子也不会少得桃子，并且每次小猴子都能刚好将桃子均分为 5 堆，而借给的那 4 个桃子每次都在剩余的那部分里，最后去除即可。
　　当第二只小猴子来时，它将 (X+4)*(4/5) 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)*(1/5) 个，剩余 (X+4)*(4/5)^2 个桃子。
　　当第三只小猴子来时，它将 (X+4)*(4/5)^2 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)^2*(1/5) 个，剩余 (X+4)*(4/5)^3 个桃子。
　　.....
　　依次类推，当第 n 只小猴子（最后一只小猴子）来时，它将 (X+4)*(4/5)^(n-1) 个桃子均分为 5 堆后，拿走 (X+4)*(4/5)^(n-1)*(1/5) 个，剩余 (X+4)*(4/5)^n 个桃子。// write your code here cpp
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0)
            break;
        long  x = pow(5,n)-4;
        long left =  (x+4)*pow(0.8,n)+n-4;
        cout<< x<<" "<<left<<endl;
    }
    return 0;
}